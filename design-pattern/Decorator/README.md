#  装饰模式

将含有特定功能的对象A，包装在其他对象B中，动态扩充对象A的功能。

## 参与者

![](https://refactoringguru.cn/images/patterns/diagrams/decorator/structure-indexed-2x.png)

1. 部件 （Component） 声明封装器和被封装对象的公用接口。

2. 具体部件 （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。

3. 基础装饰 （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。

    装饰基类会将所有操作委派给被封装的对象。

4. 具体装饰类 （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。

5. 客户端 （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。

## 优缺点

1. 你无需创建新子类即可扩展对象的行为。
2. 你可以在运行时添加或删除对象的功能。
3. 你可以用多个装饰封装对象来组合几种行为。
4. 单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。 

但是

1. 在封装器栈中删除特定封装器比较困难。
2. 实现行为不受装饰栈顺序影响的装饰比较困难。
3. 各层的初始化配置代码看上去可能会很糟糕。
